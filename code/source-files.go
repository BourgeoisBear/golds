package code

import (
	"bytes"
	"fmt"
	"go/ast"
	"io/ioutil"
	"log"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
)

func (d *CodeAnalyzer) CollectSourceFiles() {
	//log.Println("=================== CollectSourceFiles")

	//d.sourceFile2PackageTable = make(map[string]SourceFile, len(d.packageList)*5)
	d.sourceFile2PackageTable = make(map[string]*Package, len(d.packageList)*5)
	d.generatedFile2OriginalFileTable = make(map[string]string, 128)
	//d.sourceFileLineOffsetTable = make(map[string]int32, 256)
	for _, pkg := range d.packageList {
		//log.Println("====== ", pkg.Path())
		//if pkg.Path() == "unsafe" {
		//	//log.Println("///============== ", pkg.PPkg.GoFiles)
		//	//ast.Print(pkg.PPkg.Fset, pkg.PPkg.Syntax[0])
		//
		//	// For unsafe package, pkg.PPkg.CompiledGoFiles is blank.
		//	// ToDo: fill it in fillUnsafePackage? (Done)
		//
		//	path := pkg.PPkg.GoFiles[0]
		//
		//	d.sourceFile2PackageTable[path] = SourceFile{
		//		Path:    path,
		//		Pkg:     pkg,
		//		AstFile: pkg.PPkg.Syntax[0],
		//	}
		//
		//	continue
		//}

		if len(pkg.PPkg.CompiledGoFiles) != len(pkg.PPkg.Syntax) {
			panic(fmt.Sprintf("!!! len(pkg.PPkg.CompiledGoFiles) != len(pkg.PPkg.Syntax), %d:%d, %s", len(pkg.PPkg.CompiledGoFiles), len(pkg.PPkg.Syntax), pkg.Path()))
		}

		for _, path := range pkg.PPkg.OtherFiles {
			d.sourceFile2PackageTable[path] = pkg
			d.stats.FilesWithoutGenerateds++
		}

		for _, path := range pkg.PPkg.CompiledGoFiles {
			d.sourceFile2PackageTable[path] = pkg
		}

		for _, path := range pkg.PPkg.GoFiles {
			if _, ok := d.sourceFile2PackageTable[path]; !ok {
				//log.Println("! in GoFiles but not CompiledGoFiles:", path)
				d.sourceFile2PackageTable[path] = pkg
			}
			d.stats.FilesWithoutGenerateds++
		}

		d.BuildCgoFileMappings(pkg)

		//d.stats.Files += int32(len(pkg.SourceFiles))
	}
}

//==================================

type SourceFileInfo struct {
	Pkg *Package // to remove one field in Identifier.

	// Filename only.
	BareFilename          string
	BareGeneratedFilename string

	// One and only one of the following two is not blank.
	//NonGoFile      string
	//OriginalGoFile string

	// The full path of a (Go or others) source file.
	// It might be blank for some cgo generated files.
	OriginalFile string

	// The followings are blank for most files.
	GeneratedFile string
	//GoFileContentOffset int32
	//GoFileLineOffset    int32

	// Non-nil for Go files.
	// If an original Go file has a corresponding generated file,
	// then the ast file is for that generated file.
	AstFile *ast.File

	// ...
	Content []byte
}

func (info *SourceFileInfo) AstBareFileName() string {
	if info.BareGeneratedFilename != "" {
		return info.BareGeneratedFilename
	}
	return info.BareFilename
}

// ToDo: find a better way to detect generated files.
var cgoGenIdent = []byte(`// Code generated by cmd/cgo; DO NOT EDIT.`)
var reposIdent = []byte(`//line `)

// https://github.com/golang/go/issues/24183
// https://github.com/golang/go/issues/26207
// https://github.com/golang/go/issues/36072
// The fucntion is not robust enough to handle all kinds of special cases.
// 1. It doesn't consider /*line file:m:n*/ form.
// 2. It doesn't handle multiple "//line ..." occurences.
// 3. It should ignore the general content enclosed in other comments.
//    /*
//    //line file:m:n
//    */
// Maybe it is best to check the comments nodes in the already provided ast.File.
func cgoFileInfo(pkg *Package, filename string, astFile *ast.File) *SourceFileInfo {
	fileContent, err := ioutil.ReadFile(filename)
	if err != nil {
		log.Println("cgoFileInfo ReadFile error:", err)
		return nil
	}

	// ToDo: the current implement strongly depends on the cgo file genenration implementation.
	//       Here it is assumed that the "// Code generated by cmd/cgo; DO NOT EDIT." is the 4th line.
	if !bytes.HasPrefix(fileContent, cgoGenIdent) {
		return &SourceFileInfo{
			Pkg:                   pkg,
			BareGeneratedFilename: filepath.Base(filename),
			OriginalFile:          "",
			GeneratedFile:         filename,
			AstFile:               astFile,
		}
	}

	for lineOffset, data := 1, fileContent; len(data) > 0; lineOffset++ {
		i := bytes.IndexByte(data, '\n')
		k := i
		if k < 0 {
			k = len(data)
		}
		if k > 0 && data[k-1] == '\r' {
			k--
		}
		for bytes.HasPrefix(data[:k], reposIdent) {
			line := bytes.TrimSpace(data[len(reposIdent):k])
			indexB := bytes.LastIndexByte(line, ':')
			if indexB < 0 {
				break
			}

			// Assume the colume offset is 1.
			var goFilename string
			if indexA := bytes.LastIndexByte(line[:indexB], ':'); indexA >= 0 {
				goFilename = string(line[:indexA])
			} else {
				goFilename = string(line[:indexB])
			}

			return &SourceFileInfo{
				Pkg:           pkg,
				BareFilename:  filepath.Base(goFilename),
				OriginalFile:  goFilename,
				GeneratedFile: filename,
				AstFile:       astFile,
				//: int32(len(fileContent) - len(data[i+1:])),
				//GoFileLineOffset:    int32(lineOffset),
			}
		}
		if i >= 0 {
			data = data[i+1:]
		}
	}

	return nil
}

func (d *CodeAnalyzer) BuildCgoFileMappings(pkg *Package) {
	if pkg.SourceFiles != nil {
		return
	}

	pkg.SourceFiles = make([]SourceFileInfo, 0, len(pkg.PPkg.CompiledGoFiles))

	for i, compiledFile := range pkg.PPkg.CompiledGoFiles {
		if strings.HasSuffix(compiledFile, ".go") {
			// ToDo: verify compiledFile must be also in  pkg.PPkg.GoFiles
			pkg.SourceFiles = append(pkg.SourceFiles,
				SourceFileInfo{
					Pkg:           pkg,
					BareFilename:  filepath.Base(compiledFile),
					OriginalFile:  compiledFile,
					GeneratedFile: compiledFile,
					AstFile:       pkg.PPkg.Syntax[i],
				},
			)
			continue
		}
		info := cgoFileInfo(pkg, compiledFile, pkg.PPkg.Syntax[i])
		if info == nil {
			log.Println(compiledFile, "!has no original file:", compiledFile)
			continue
		}

		if info.OriginalFile != "" && info.GeneratedFile != info.OriginalFile {
			d.generatedFile2OriginalFileTable[info.GeneratedFile] = info.OriginalFile
		}

		//info.AstFile = pkg.PPkg.Syntax[i]
		pkg.SourceFiles = append(pkg.SourceFiles, *info)

		//if info.GoFileLineOffset != 0 {
		//	d.sourceFileLineOffsetTable[info.OriginalGoFile] = info.GoFileLineOffset
		//}
	}

	for _, path := range pkg.PPkg.OtherFiles {
		pkg.SourceFiles = append(pkg.SourceFiles,
			SourceFileInfo{
				Pkg:          pkg,
				BareFilename: filepath.Base(path),
				OriginalFile: path,
			},
		)
	}
}

func (d *CodeAnalyzer) CollectObjectReferences() {
	for _, pkg := range d.packageList {
		for i := range pkg.SourceFiles {
			info := &pkg.SourceFiles[i]
			//log.Println("===", info.OriginalGoFile)
			//log.Println("   ", info.GeneratedFile, info.GoFileContentOffset)
			if info.AstFile == nil {
				continue
			}
			d.CollectIdentiferFromFile(pkg, info)
		}
	}
}

func (d *CodeAnalyzer) CollectIdentiferFromFile(pkg *Package, fileInfo *SourceFileInfo) {
	ast.Inspect(fileInfo.AstFile, func(n ast.Node) bool {
		switch n := n.(type) {
		case *ast.Ident:
			obj := pkg.PPkg.TypesInfo.ObjectOf(n)
			if obj != nil {
				d.regObjectReference(obj, fileInfo, n)
			}
			// ToDo: also collect some implicit refs.
		}
		return true
	})
}

// ToDo: can we get the content from the collected AST files?
//       Need to hack the std packages?
func (d *CodeAnalyzer) CacheSourceFiles() {
	n := runtime.GOMAXPROCS(-1)
	sem := make(chan struct{}, n)
	var wg sync.WaitGroup
	defer wg.Wait()

	for _, pkg := range d.packageList {
		for i := range pkg.SourceFiles {
			wg.Add(1)
			info := &pkg.SourceFiles[i]
			filePath := info.OriginalFile
			if info.GeneratedFile != "" {
				filePath = info.GeneratedFile
			}

			sem <- struct{}{}
			go func() {
				defer func() {
					<-sem
					wg.Done()
				}()

				content, err := ioutil.ReadFile(filePath)
				if err != nil {
					log.Printf("ReadFile (%s) error: %s", filePath, err)
					return
				}
				info.Content = content
				//log.Printf("ReadFile (%s) done", filePath)
			}()
		}
	}
}
